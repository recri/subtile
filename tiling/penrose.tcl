########################################################################
##
## Penrose tilings.
##
## The penrose kite-and-dart tiling is dissected into the A
## triangulation by dividing kites along their long diagonals and darts
## along their short diagonals.
## The penrose rhomb tiling is dissected into the B triangulation by
## dividing the large rhombs along their long diagonals and the small
## rhomb along their short diagonals.
## The penrose A trianguluation is dissected into the B triangulation
## by renaming the small A triangles into large B triangles and
## dividing the large A triangles into large B and small B
## triangles.
## The penrose B triangulation is dissected into the A triangulation
## by renaming the small B triangles into large A triangles and
## dividing the large B triangles into large A and small A triangles.
##
## The reverse annealing steps are also supported.
##
## There are further complicating details necessary to preserve the
## vertex colorings which distinguish left and right handed forms of
## each triangle.
##
## Each triangle is represented as a name and three vertices.  The
## vertices are listed in counter clockwise order starting from the
## lower left corner when the triangle is sitting on its base with the
## two equal edges pointing up.  (Life would be simpler if I ordered
## the mirror image vertices as clockwise).
##
##         +
##        / \
##       /   \
##      /     \
##     /       \
##    /         \
##   /           \
##  /             \
## o---------------+
##

lappend subtile(tilings) \
    {{Penrose kite and dart} penrose-KD} \
    {{Penrose rhomb} penrose-R} \
    {{Penrose B triangles} penrose-B}\
    {{Penrose A triangles} penrose-A};

set penrose(pt) [expr (1/$Tau)/(1+1/$Tau)];
set penrose(pT) [expr 1/(1+$Tau)];
set penrose(pT2) [expr 1/($Tau*$Tau)];

#
#
#
proc penrose-about {tiles} {
    about-something {About Penrose Tilings} {
	The Penrose tilings are discussed at length in Senechal (1995) and in
	Gruenbaum and Shephard (1987).

	Subtile implements the kite and dart tiling, the rhomb tiling, and the
	two triangulations generated by slicing kites, darts, and rhombs into
	halves.

	The A triangulation is generated by slicing kites along their long
	diagonals and darts along their short diagonals.

	The B triangulation is generated by slicing large rhombs along their
	long diagonals and small rhombs along their short diagonals.

	The A and B triangulations can be converted into each other by
	dissection or annealing. 
    }
    return $tiles;
}
#
# kite and dart tilings
#
set a [vmake 0 $Tau*sin($Pi/5)];
set b [vmake ($Tau+1)/2 0];
set c [vmake $Tau+1 $Tau*sin($Pi/5)];
set d [vmake ($Tau+1)/2 2*$Tau*sin($Pi/5)];
set e [vadd $a [vscale $Tau/($Tau+1) [vsub $c $a]]];

set K [list [list penrose-KD-K $d $e $b $a]];
set D [list [list penrose-KD-D $d $c $b $e]];

set subtile(penrose-KD-ops-menu) \
    [list \
	 {{About Penrose Tilings} penrose-about} \
	 {{Dissect to A triangles} penrose-do-KD-dissect-to-A} \
	];
set subtile(penrose-KD-start-menu) \
    [list \
	 [list Kite $K]\
	 [list Dart $D] \
	];

proc penrose-do-KD-dissect-to-A {tiles} {
    return [list penrose-A [penrose-KD-dissect-to-A $tiles]];
}

proc penrose-KD-make {tiles divide} {
    if {$divide == 0} {
	return [list penrose-KD $tiles];
    } else {
	return [list penrose-KD \
		    [penrose-A-anneal-to-KD \
			 [penrose-B-dissect-to-A \
			      [penrose-A-dissect-to-B \
				   [penrose-KD-dissect-to-A $tiles]]]]];
    }
}

#
# A triangle tilings - dissection of kite and dart
#
set TL [list [list penrose-A-TL\
		  [vmake 0 $Tau*sin(2*$Pi/5)]\
		  [vmake 1 $Tau*sin(2*$Pi/5)]\
		  [vmake 0.5 0]]];
set TR [list [list penrose-A-TR\
		  [vmake 1 $Tau*sin(2*$Pi/5)]\
		  [vmake 0 $Tau*sin(2*$Pi/5)]\
		  [vmake 0.5 2*$Tau*sin(2*$Pi/5)]]];
set tL [list [list penrose-A-tL\
		  [vmake 0 sin($Pi/5)]\
		  [vmake $Tau sin($Pi/5)]\
		  [vmake $Tau/2 0]]];
set tR [list [list penrose-A-tR\
		  [vmake $Tau sin($Pi/5)]\
		  [vmake 0 sin($Pi/5)]\
		  [vmake $Tau/2 2*sin($Pi/5)]]];
set subtile(penrose-A-ops-menu) \
    [list \
	 {{About Penrose Tilings} penrose-about} \
	 {{Anneal to kites and darts} penrose-do-A-anneal-to-KD} \
	 {{Dissect to B triangles} penrose-do-A-dissect-to-B} \
	 {{Anneal to B triangles} penrose-do-A-anneal-to-B} \
	];
set subtile(penrose-A-start-menu) \
    [list \
	 [list {Small A Left} $tL] \
	 [list {Small A Right} $tR] \
	 [list {Large A Left} $TL] \
	 [list {Large A Right} $TR] \
	];

proc penrose-do-A-anneal-to-KD {tiles} {
    return [list penrose-KD [penrose-A-anneal-to-KD $tiles]];
}

proc penrose-do-A-dissect-to-B {tiles} {
    return [list penrose-B [penrose-A-dissect-to-B $tiles]];
}
proc penrose-do-A-anneal-to-B {tiles} {
    return [list penrose-B [penrose-A-anneal-to-B $tiles]];
}
proc penrose-A-make {tiles divide} {
    if {$divide == 0} {
	return [list penrose-A $tiles];
    } else {
	return [list penrose-A [penrose-B-dissect-to-A [penrose-A-dissect-to-B $tiles]]];
    }
}

#
# B triangle tilings - dissection of rhombs, dissection or annealing of A triangles.
#
set tL [list [list penrose-B-tL\
		  [vmake 0 $Tau*sin(2*$Pi/5)]\
		  [vmake 1 $Tau*sin(2*$Pi/5)]\
		  [vmake 0.5 0]]];
set tR [list [list penrose-B-tR\
		  [vmake 1 $Tau*sin(2*$Pi/5)]\
		  [vmake 0 $Tau*sin(2*$Pi/5)]\
		  [vmake 0.5 2*$Tau*sin(2*$Pi/5)]]];
set TL [list [list penrose-B-TL\
		  [vmake 0 $Tau*sin($Pi/5)]\
		  [vmake $Tau+1 $Tau*sin($Pi/5)]\
		  [vmake ($Tau+1)/2 0]]];
set TR [list [list penrose-B-TR\
		  [vmake $Tau+1 $Tau*sin($Pi/5)]\
		  [vmake 0 $Tau*sin($Pi/5)]\
		  [vmake ($Tau+1)/2 2*$Tau*sin($Pi/5)]]];
set subtile(penrose-B-ops-menu) \
    [list \
	 {{About Penrose Tilings} penrose-about} \
	 {{Anneal to rhombs} penrose-do-B-anneal-to-R} \
	 {{Dissect to A triangles} penrose-do-B-dissect-to-A} \
	 {{Anneal to A triangles} penrose-do-B-anneal-to-A} \
	];
set subtile(penrose-B-start-menu) \
    [list \
	 [list {Small B Left} $tL] \
	 [list {Small B Right} $tR] \
	 [list {Large B Left} $TL] \
	 [list {Large B Right} $TR] \
	];

proc penrose-do-B-anneal-to-R {tiles} {
    return [list penrose-R [penrose-B-anneal-to-R $tiles]];
}
proc penrose-do-B-dissect-to-A {tiles} {
    return [list penrose-A [penrose-B-dissect-to-A $tiles]];
}
proc penrose-do-B-anneal-to-A {tiles} {
    return [list penrose-A [penrose-B-anneal-to-A $tiles]];
}
proc penrose-B-make {tiles divide} {
    if {$divide == 0} {
	return [list penrose-B $tiles];
    } else {
	return [list penrose-B [penrose-A-dissect-to-B [penrose-B-dissect-to-A $tiles]]];
    }
}
    
#
# rhomb tilings
#
set r [list [list penrose-R-r\
		 [vmake 0 $Tau*sin(2*$Pi/5)]\
		 [vmake 0.5 0]\
		 [vmake 1 $Tau*sin(2*$Pi/5)]\
		 [vmake 0.5 2*$Tau*sin(2*$Pi/5)]]];
set R [list [list penrose-R-R\
		 [vmake 0 $Tau*sin($Pi/5)]\
		 [vmake ($Tau+1)/2 0]\
		 [vmake $Tau+1 $Tau*sin($Pi/5)]\
		 [vmake ($Tau+1)/2 2*$Tau*sin($Pi/5)]]];
set subtile(penrose-R-ops-menu) \
    [list \
	 {{About Penrose Tilings} penrose-about} \
	 {{Dissect to B triangles} penrose-do-R-dissect-to-B} \
	];
set subtile(penrose-R-start-menu) \
    [list \
	 [list {Large rhomb} $R] \
	 [list {Small rhomb} $r] \
	];

proc penrose-do-R-dissect-to-B {tiles} {
    return [list penrose-B [penrose-R-dissect-to-B $tiles]];
}
proc penrose-R-make {tiles divide} {
    if {$divide == 0} {
	return [list penrose-R $tiles];
    } else {
	return [list penrose-R \
		    [penrose-B-anneal-to-R \
			 [penrose-A-dissect-to-B \
			      [penrose-B-dissect-to-A \
				   [penrose-R-dissect-to-B $tiles]]]]];
    }
}

#
# annealing utility
#
proc penrose-tile-match {type listname tilename} {
    upvar $listname list;
    upvar $tilename tile;
    if { ! [info exists list]} {
	return 0;
    }
    for {set i 0} {$i < [llength $list]} {incr i} {
	set t1 [lindex $list $i];
	if {"[lindex $t1 0]" == "$type"} {
	    set list [lreplace $list $i $i];
	    if {"$list" == {}} {
		unset list;
	    }
	    set tile $t1;
	    return 1;
	}
    }
    return 0;
}

    
#
# dissect a list of penrose-R tiles to a list of penrose-B tiles
#
proc penrose-R-dissect-to-B {tiles} {
    set newt {};
    foreach tile $tiles {
	set type [lindex $tile 0];
	set a [lindex $tile 1];
	set b [lindex $tile 2];
	set c [lindex $tile 3];
	set d [lindex $tile 4];
	switch -exact $type {
	    penrose-R-R {
		lappend newt [list penrose-B-TL $a $c $b] [list penrose-B-TR $c $a $d];
	    }
	    penrose-R-r {
		lappend newt [list penrose-B-tL $a $c $b] [list penrose-B-tR $c $a $d];
	    }
	    default {
		error "found tile of type $type";
	    }
	}
    }
    return $newt;
}

#
# anneal a list of penrose-B tiles to a list of penrose-R tiles
#
proc penrose-B-anneal-to-R {tiles} {
    set newt {};
    foreach t1 $tiles {
	set type [lindex $t1 0];
	set a [lindex $t1 1];
	set b [lindex $t1 2];
	set c [lindex $t1 3];
	switch -exact $type {
	    penrose-B-tL {
		set point $a,$b;
		if {[penrose-tile-match penrose-B-tR t($point) t2]} {
		    lappend newt [list penrose-R-r $a $c [lindex $t2 1] [lindex $t2 3]];
		} else {
		    lappend t($point) $t1;
		}
	    }
	    penrose-B-tR {
		set point $b,$a;
		if {[penrose-tile-match penrose-B-tL t($point) t2]} {
		    lappend newt [list penrose-R-r [lindex $t2 1] [lindex $t2 3] $a $c];
		} else {
		    lappend t($point) $t1;
		}
	    }
	    penrose-B-TL {
		set point $a,$b;
		if {[penrose-tile-match penrose-B-TR t($point) t2]} {
		    lappend newt [list penrose-R-R $a $c [lindex $t2 1] [lindex $t2 3]];
		} else {
		    lappend t($point) $t1;
		}
	    }
	    penrose-B-TR {
		set point $b,$a;
		if {[penrose-tile-match penrose-B-TL t($point) t2]} {
		    lappend newt [list penrose-R-R [lindex $t2 1] [lindex $t2 3] $a $c];
		} else {
		    lappend t($point) $t1;
		}
	    }
	    default {
		error "found tile of type $type";
	    }
	}
    }
    return $newt;
}

#
# dissect a list of penrose-B tiles to a list of penrose-A tiles
#
proc penrose-B-dissect-to-A {tiles} {
    upvar \#0 penrose(pT) pT;
    set newt {};
    foreach tile $tiles {
	set type [lindex $tile 0];
	set a [lindex $tile 1];
	set b [lindex $tile 2];
	set c [lindex $tile 3];
	switch -exact $type {
	    penrose-B-tL {
		lappend newt [list penrose-A-TL $a $b $c];
	    }
	    penrose-B-tR {
		lappend newt [list penrose-A-TR $a $b $c];
	    }
	    penrose-B-TL {
		set d [vadd $b [vscale $pT [vsub $a $b]]];
		lappend newt [list penrose-A-TR $d $c $a] [list penrose-A-tL $b $c $d];
	    }
	    penrose-B-TR {
		set d [vadd $a [vscale $pT [vsub $b $a]]];
		lappend newt [list penrose-A-TL $c $d $b] [list penrose-A-tR $c $a $d];
	    }
	    default {
		error "found tile of type $type";
	    }
	}
    }
    return $newt;
}

#
# anneal a list of penrose-A tiles to a list of penrose-B tiles
#
proc penrose-A-anneal-to-B {tiles} {
    set newt {};
    foreach t1 $tiles {
	set type [lindex $t1 0];
	set a [lindex $t1 1];
	set b [lindex $t1 2];
	set c [lindex $t1 3];
	switch -exact $type {
	    penrose-A-tL {
		set point $b,$c;
		if {[penrose-tile-match penrose-A-TR t($point) t2]} {
		    lappend newt [list penrose-B-TL [lindex $t2 3] $a $b];
		} else {
		    lappend t($point) $t1;
		}
	    }
	    penrose-A-TR {
		set point $b,$a;
		if {[penrose-tile-match penrose-A-tL t($point) t2]} {
		    lappend newt [list penrose-B-TL $c [lindex $t2 1] [lindex $t2 2]];
		} else {
		    lappend t($point) $t1;
		}
	    }
	    penrose-A-TL {
		set point $a,$b;
		if {[penrose-tile-match penrose-A-tR t($point) t2]} {
		    lappend newt [list penrose-B-TR [lindex $t2 2] $c $a];
		} else {
		    lappend t($point) $t1;
		}
	    }
	    penrose-A-tR {
		set point $a,$c;
		if {[penrose-tile-match penrose-A-TL t($point) t2]} {
		    lappend newt [list penrose-B-TR $b [lindex $t2 3] [lindex $t2 1]];
		} else {
		    lappend t($point) $t1;
		}
	    }
	    default {
		error "found tile of type $type";
	    }
	}
    }
    foreach point [array names t] {
	foreach t1 $t($point) {
	    set type [lindex $t1 0];
	    set a [lindex $t1 1];
	    set b [lindex $t1 2];
	    set c [lindex $t1 3];
	    switch -exact $type {
		penrose-A-TR {
		    lappend newt [list penrose-B-tR $a $b $c];
		}
		penrose-A-TL {
		    lappend newt [list penrose-B-tL $a $b $c];
		}
		default {
		    puts stderr "leftover tile: $t1";
		}
	    }
	}
    }
    return $newt;
}
#
# dissect a list of penrose-A tiles into a list of penrose-B tiles
#
proc penrose-A-dissect-to-B {tiles} {
    upvar \#0 penrose(pT2) pT2;
    set newt {};
    foreach tile $tiles {
	set type [lindex $tile 0];
	set a [lindex $tile 1];
	set b [lindex $tile 2];
	set c [lindex $tile 3];
	switch -exact $type {
	    penrose-A-tL {
		lappend newt [list penrose-B-TL $a $b $c];
	    }
	    penrose-A-tR {
		lappend newt [list penrose-B-TR $a $b $c];
	    }
	    penrose-A-TL {
		set d [vadd $a [vscale $pT2 [vsub $c $a]]];
		lappend newt [list penrose-B-TL $b $c $d] [list penrose-B-tL $d $a $b];
	    }
	    penrose-A-TR {
		set d [vadd $b [vscale $pT2 [vsub $c $b]]];
		lappend newt [list penrose-B-TR $c $a $d] [list penrose-B-tR $b $d $a];
	    }
	    default {
		error "found tile of type $type";
	    }
	}
    }
    return $newt;
}
#
# anneal a list of penrose-B tiles into a list of penrose-A tiles
#
proc penrose-B-anneal-to-A {tiles} {
    set newt {};
    foreach t1 $tiles {
	set type [lindex $t1 0];
	set a [lindex $t1 1];
	set b [lindex $t1 2];
	set c [lindex $t1 3];
	switch -exact $type {
	    penrose-B-tL {
		set point $a,$c;
		if {[penrose-tile-match penrose-B-TL t($point) t2]} {
		    lappend newt [list penrose-A-TL $b $c [lindex $t2 2]];
		} else {
		    lappend t($point) $t1;
		}
	    }
	    penrose-B-TL {
		set point $c,$a;
		if {[penrose-tile-match penrose-B-tL t($point) t2]} {
		    lappend newt [list penrose-A-TL [lindex $t2 2] [lindex $t2 3] $b];
		} else {
		    lappend t($point) $t1;
		}
	    }
	    penrose-B-tR {
		set point $b,$c;
		if {[penrose-tile-match penrose-B-TR t($point) t2]} {
		    lappend newt [list penrose-A-TR $c $a [lindex $t2 1]];
		} else {
		    lappend t($point) $t1;
		}
	    }
	    penrose-B-TR {
		set point $c,$b;
		if {[penrose-tile-match penrose-B-tR t($point) t2]} {
		    lappend newt [list penrose-A-TR [lindex $t2 3] [lindex $t2 1] $a];
		} else {
		    lappend t($point) $t1;
		}
	    }
	    default {
		error "found tile of type $type";
	    }
	}
    }
    foreach point [array names t] {
	foreach t1 $t($point) {
	    set type [lindex $t1 0];
	    set a [lindex $t1 1];
	    set b [lindex $t1 2];
	    set c [lindex $t1 3];
	    switch -exact $type {
		penrose-B-TR {
		    lappend newt [list penrose-A-tR $a $b $c];
		}
		penrose-B-TL {
		    lappend newt [list penrose-A-tL $a $b $c];
		}
		default {
		    puts stderr "leftover tile: $t1";
		}
	    }
	}
    }
    return $newt;
}
#
# dissect a list of penrose-KD tiles into a list of penrose-A tiles
#
proc penrose-KD-dissect-to-A {tiles} {
    set newt {};
    foreach tile $tiles {
	set type [lindex $tile 0];
	set a [lindex $tile 1];
	set b [lindex $tile 2];
	set c [lindex $tile 3];
	set d [lindex $tile 4];
	switch -exact $type {
	    penrose-KD-K {
		lappend newt [list penrose-A-TL $b $c $d] [list penrose-A-TR $a $b $d];
	    }
	    penrose-KD-D {
		lappend newt [list penrose-A-tL $b $c $d] [list penrose-A-tR $a $b $d];
	    }
	    default {
		error "found tile of type $type";
	    }
	}
    }
    return $newt;
}
#
# anneal a list of penrose-A tiles into a list of penrose-A tiles
#
proc penrose-A-anneal-to-KD {tiles} {
    set newt {};
    foreach t1 $tiles {
	set type [lindex $t1 0];
	set a [lindex $t1 1];
	set b [lindex $t1 2];
	set c [lindex $t1 3];
	switch -exact $type {
	    penrose-A-tL {
		set point $a,$c;
		if {[info exists t($point)]} {
		    set t2 [lindex $t($point) 0];
		    lappend newt [list penrose-KD-D [lindex $t2 1] [lindex $t2 2] $b $c];
		    unset t($point);
		} else {
		    lappend t($point) $t1;
		}
	    }
	    penrose-A-tR {
		set point $b,$c;
		if {[info exists t($point)]} {
		    set t2 [lindex $t($point) 0];
		    lappend newt [list penrose-KD-D $a $b [lindex $t2 2] [lindex $t2 3]];
		    unset t($point);
		} else {
		    lappend t($point) $t1;
		}
	    }
	    penrose-A-TL {
		set point $a,$c;
		if {[info exists t($point)]} {
		    set t2 [lindex $t($point) 0];
		    lappend newt [list penrose-KD-K [lindex $t2 1] [lindex $t2 2] $b $c];
		    unset t($point);
		} else {
		    lappend t($point) $t1;
		}
	    }
	    penrose-A-TR {
		set point $b,$c;
		if {[info exists t($point)]} {
		    set t2 [lindex $t($point) 0];
		    lappend newt [list penrose-KD-K $a $b [lindex $t2 2] [lindex $t2 3]];
		    unset t($point);
		} else {
		    lappend t($point) $t1;
		}
	    }
	    default {
		error "found tile of type $type";
	    }
	}
    }
    return $newt;
}


